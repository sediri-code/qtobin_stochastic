# -*- coding: utf-8 -*-
"""projet_federateur.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CiBaQTfg-nvcTrpnz-xRC7YnwMYNgdP5
"""

pip install pandas matplotlib yfinance

import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt
from datetime import datetime,date

# Liste des symboles d'actions à importer (par exemple, AAPL, MSFT, GOOGL, etc.)

stocks = ['AAPL', 'MSFT', 'V', 'MA','INTC','IRX']
date_debut = "2023-01-01"

# Obtention de la date d'aujourd'hui

date_aujourdhui = date.today()

# Conversion de la date d'aujourd'hui en chaîne de caractères au format AAAA-MM-JJ

date_aujourdhui_str = date_aujourdhui.strftime("%Y-%m-%d")

# Assignation de la date d'aujourd'hui à la variable date_fin
date_fin = date_aujourdhui_str

# Boucle pour obtenir les dividendes actuels pour chaque action
for stock_symbol in stocks:
    stock = yf.Ticker(stock_symbol)
    dividends = stock.dividends
    if not dividends.empty:
        latest_dividend = dividends.iloc[-1]  # Récupérer le dernier dividende
        print(f"Dividende actuel pour {stock_symbol}: {latest_dividend:.2f}")
    else:
        print(f"Aucune information sur les dividendes pour {stock_symbol}")

import yfinance as yf


stocks = ['AAPL', 'MA', 'MSFT','V','INTC']  # Ajoutez les symboles d'actions ici
tauxC =[]
for stock_symbol in stocks:
    stock = yf.Ticker(stock_symbol)
    historical_data = stock.history(period="max")  # Obtenir l'historique des prix
    if not historical_data.empty and len(historical_data) >= 2:
        initial_price = historical_data.iloc[0]['Open']
        final_price = historical_data.iloc[-1]['Open']

        # Calcul du taux de croissance annuel composé (TCAC)
        time_period = len(historical_data) - 1  # Période en années
        growth_rate = ((final_price / initial_price) ** (1 / time_period)) - 1

        tauxC.append(growth_rate)

        print(f"Taux de croissance pour {stock_symbol}: {growth_rate * 100:.2f}%")

    else:
        print(f"Insuffisamment de données pour calculer le taux de croissance de {stock_symbol}")

print(tauxC) #affichage de chaque taux de croissance dans un tableau

import yfinance as yf
from datetime import datetime, date

# Définir la date de début et de fin
date_debut = "2023-01-01"
date_fin = date.today().strftime("%Y-%m-%d")

# Récupération des données de l'indice S&P 500
snp500 = yf.Ticker('^GSPC')  # Le symbole ^GSPC représente l'indice S&P 500

# Récupération de l'historique des prix de l'indice S&P 500 sur une période spécifique
historical_data_snp500 = snp500.history(start=date_debut, end=date_fin)

# Vérifier si suffisamment de données sont disponibles pour calculer le rendement du marché
if not historical_data_snp500.empty and len(historical_data_snp500) >= 2:
    initial_value = historical_data_snp500.iloc[0]['Close']
    final_value = historical_data_snp500.iloc[-1]['Close']

    # Calcul du rendement du marché
    rm = ((final_value - initial_value) / initial_value) * 100

    print(f"Rendement du marché (S&P 500) sur la période spécifiée : {rm:.2f}%")
else:
    print("Insuffisamment de données pour calculer le rendement du marché (S&P 500) sur cette période")


# Fonction pour calculer la variance du marché
def calculer_variance_marche(start_date, end_date):
    # Récupération des données de l'indice S&P 500
    snp500 = yf.Ticker('^GSPC')  # Le symbole ^GSPC représente l'indice S&P 500

    # Récupération de l'historique des prix de l'indice S&P 500 sur une période spécifique
    historical_data_snp500 = snp500.history(start=start_date, end=end_date)

    # Vérifier si suffisamment de données sont disponibles pour calculer la variance
    if not historical_data_snp500.empty and len(historical_data_snp500) >= 2:
        # Sélection des prix de clôture pour le calcul de la variance
        closing_prices = historical_data_snp500['Close']

        # Calcul de la variance
        market_variance = closing_prices.var()

        return market_variance

    else:
        print("Insuffisamment de données pour calculer la variance du marché sur cette période")
        return None

# Appel de la fonction pour calculer la variance du marché
variance_marche = calculer_variance_marche(date_debut, date_fin)
if variance_marche is not None:
    print(f"Variance du marché (S&P 500) sur la période spécifiée : {variance_marche:.2f}")

#calculer Rf
import yfinance as yf

# Récupération des données de l'indice S&P 500
irx = yf.Ticker('^IRX')  # Le symbole ^GSPC représente l'indice S&P 500

# Récupération de l'historique des prix de l'indice S&P 500 sur une période spécifique
historical_data_irx = irx.history(start=date_debut, end=date_fin)
# Remplacez 'YYYY-MM-DD' par les dates de début et de fin souhaitées pour calculer le rendement

if not historical_data_irx.empty and len(historical_data_irx) >= 2:
    initial_value = historical_data_irx.iloc[0]['Close']
    final_value = historical_data_irx.iloc[-1]['Close']

    # Calcul du rendement du marché
    rf = ((final_value - initial_value) / initial_value) * 100

    print(f"Rendement sans Risque (Rf) sur la période spécifiée : {rf:.2f}%")
else:
    print("Insuffisamment de données pour calculer le rendement sans risque sur cette période")

import yfinance as yf

# 1ère méthode
# Récupération des données de l'action Apple (AAPL)
aapl = yf.Ticker('AAPL')  # Le symbole ^GSPC représente l'indice S&P 500

# Récupération de l'historique des prix de l'action Apple sur une période spécifique
historical_data_aapl = aapl.history(start=date_debut, end=date_fin)
# Remplacez 'YYYY-MM-DD' par les dates de début et de fin souhaitées pour calculer le rendement

if not historical_data_aapl.empty and len(historical_data_aapl) >= 2:
    valeur_initiale = historical_data_aapl.iloc[0]['Close']
    valeur_finale = historical_data_aapl.iloc[-1]['Close']

    # Calcul du rendement du marché
    rendement_marche = ((valeur_finale - valeur_initiale) / valeur_initiale) * 100

    print(f"Rendement de l'action Apple sur la période spécifiée : {rendement_marche:.2f}%")
else:
    print("Insuffisamment de données pour calculer le rendement de l'action Apple sur cette période")

# Calcul du coefficient beta
covariance = historical_data_aapl['Close'].cov(historical_data_snp500['Close'])
variance_marche = calculer_variance_marche(date_debut, date_fin)
beta = covariance / variance_marche
print(f"Coefficient bêta (beta) de l'action Apple par rapport au marché : {beta:.2f}")
# MEDAF : Ks = rf + (Rm – rf) * Beta
ks = rf + (rm - rf) * beta
print(f"La valeur du MEDAF : {ks:.3F}")

if rendement_marche > ks:
    print("Action recommandée : Achat d'actions Apple")
else:
    print("Action recommandée : Ne pas acheter d'actions Apple")

# Calcul de Gordon-Shapiro
G = (latest_dividend / final_price) + tauxC[0]
print(f"La valeur de Gordon-Shapiro est : {G:.3F}")

if rendement_marche > G:
    print("Action recommandée : Achat d'actions Apple")
else:
    print("Action recommandée : Ne pas acheter d'actions Apple")

# 2ème méthode QTOBIN
Qtobin = final_price / 3.97
### 3.97 = valeur comptable par action

print(f"La valeur de Q de Tobin est égale à : {Qtobin:.3F}")

if Qtobin > 1:
    print("Action recommandée : Achat d'actions Apple")
else:
    print("Action recommandée : Ne pas acheter d'actions Apple")

### https://fr.investing.com/equities/apple-computer-inc-ratios

# 3ème méthode stochastique
cours_bas = historical_data_aapl.iloc[-1]['Low']
cours_haut = historical_data_aapl.iloc[-1]['High']
S = (valeur_finale - cours_bas) / (cours_haut - cours_bas)

print(f"La valeur stochastique est égale à : {S:.3F}")

if S < 20:
    print("Action recommandée : Achat d'actions Apple")
else:
    print("Action recommandée : Ne pas acheter d'actions Apple")

import yfinance as yf

# Récupération des données de l'action Microsoft (MSFT)
MSFT = yf.Ticker('MSFT')  # Le symbole ^GSPC représente l'indice S&P 500

# Récupération de l'historique des prix de l'action Microsoft sur une période spécifique
historique_MSFT = MSFT.history(start=date_debut, end=date_fin)
# Remplacez 'YYYY-MM-DD' par les dates de début et de fin souhaitées pour calculer le rendement

if not historique_MSFT.empty and len(historique_MSFT) >= 2:
    valeur_initiale = historique_MSFT.iloc[0]['Close']
    valeur_finale = historique_MSFT.iloc[-1]['Close']

    # Calcul du rendement du marché
    rendement_marche = ((valeur_finale - valeur_initiale) / valeur_initiale) * 100

    print(f"Rendement de Microsoft sur la période spécifiée : {rendement_marche:.2f}%")
else:
    print("Insuffisamment de données pour calculer le rendement de Microsoft sur cette période")

# Calcul du coefficient beta
covariance = historique_MSFT['Close'].cov(historical_data_snp500['Close'])
variance_marche = calculer_variance_marche(date_debut, date_fin)
beta = covariance / variance_marche
print(f"Coefficient bêta (beta) de Microsoft par rapport au marché : {beta:.2f}")
# MEDAF : Ks = rf + (Rm – rf) * Beta
ks = rf + (rm - rf) * beta
print(f"La valeur du MEDAF : {ks:.3F}")

if rendement_marche > ks:
    print("Action recommandée : Achat d'actions Microsoft")
else:
    print("Action recommandée : Ne pas acheter d'actions Microsoft")

# Calcul de Gordon-Shapiro
G = (latest_dividend / final_price) + tauxC[1]
print(f"La valeur de Gordon-Shapiro est : {G:.3F}")

if rendement_marche > G:
    print("Action recommandée : Achat d'actions Microsoft")
else:
    print("Action recommandée : Ne pas acheter d'actions Microsoft")

# 2ème méthode QTOBIN
Qtobin = final_price / 29.71
### 29.71 = valeur comptable par action

print(f"Le Q de Tobin est égal à : {Qtobin:.3F}")

if Qtobin > 1:
    print("Action recommandée : Achat d'actions Microsoft")
else:
    print("Action recommandée : Ne pas acheter d'actions Microsoft")

### https://fr.investing.com/equities/Microsoft-computer-inc-ratios

# 3ème méthode stochastique
cours_bas = historique_MSFT.iloc[-1]['Low']
cours_haut = historique_MSFT.iloc[-1]['High']
S = (valeur_finale - cours_bas) / (cours_haut - cours_bas)

print(f"La valeur stochastique est égale à : {S:.3F}")

if S < 20:
    print("Action recommandée : Achat d'actions Microsoft")
else:
    print("Action recommandée : Ne pas acheter d'actions Microsoft")

import yfinance as yf

# Récupération des données de l'action Visa (V)
v = yf.Ticker('V')  # Le symbole ^V représente l'indice S&P 500

# Récupération de l'historique des prix de l'action Visa sur une période spécifique
historique_v = v.history(start=date_debut, end=date_fin)
# Remplacez 'YYYY-MM-DD' par les dates de début et de fin souhaitées pour calculer le rendement

if not historique_v.empty and len(historique_v) >= 2:
    valeur_initiale = historique_v.iloc[0]['Close']
    valeur_finale = historique_v.iloc[-1]['Close']

    # Calcul du rendement du marché
    rendement_marche = ((valeur_finale - valeur_initiale) / valeur_initiale) * 100

    print(f"Rendement de Visa sur la période spécifiée : {rendement_marche:.2f}%")
else:
    print("Insuffisamment de données pour calculer le rendement de Visa sur cette période")

# Calcul du coefficient beta
covariance = historique_v['Close'].cov(historical_data_snp500['Close'])
variance_marche = calculer_variance_marche(date_debut, date_fin)
beta = covariance / variance_marche
print(f"Coefficient bêta (beta) de Visa par rapport au marché : {beta:.2f}")
# MEDAF : Ks = rf + (Rm – rf) * Beta
ks = rf + (rm - rf) * beta
print(f"La valeur du MEDAF : {ks:.3F}")

if rendement_marche > ks:
    print("Action recommandée : Achat d'actions Visa")
else:
    print("Action recommandée : Ne pas acheter d'actions Visa")

# Calcul de Gordon-Shapiro
G = (latest_dividend / final_price) + tauxC[2]
print(f"La valeur de Gordon-Shapiro est : {G:.3F}")

if rendement_marche > G:
    print("Action recommandée : Achat d'actions Visa")
else:
    print("Action recommandée : Ne pas acheter d'actions Visa")

# 2ème méthode QTOBIN
Qtobin = final_price / 18.2
### 18.2 = valeur comptable par action

print(f"Le Q de Tobin est égal à : {Qtobin:.3F}")

if Qtobin > 1:
    print("Action recommandée : Achat d'actions Visa")
else:
    print("Action recommandée : Ne pas acheter d'actions Visa")

### https://fr.investing.com/equities/Visa-computer-inc-ratios

# 3ème méthode stochastique
cours_bas = historique_v.iloc[-1]['Low']
cours_haut = historique_v.iloc[-1]['High']
S = (valeur_finale - cours_bas) / (cours_haut - cours_bas)

print(f"La valeur stochastique est égale à : {S:.3F}")

if S < 20:
    print("Action recommandée : Achat d'actions Visa")
else:
    print("Action recommandée : Ne pas acheter d'actions Visa")

import yfinance as yf

# Récupération des données de l'action Mastercard (MA)
ma = yf.Ticker('MA')  # Le symbole ^GSPC représente l'indice S&P 500

# Récupération de l'historique des prix de l'action Mastercard sur une période spécifique
historique_ma = ma.history(start=date_debut, end=date_fin)
# Remplacez 'YYYY-MM-DD' par les dates de début et de fin souhaitées pour calculer le rendement

if not historique_ma.empty and len(historique_ma) >= 2:
    valeur_initiale = historique_ma.iloc[0]['Close']
    valeur_finale = historique_ma.iloc[-1]['Close']

    # Calcul du rendement du marché
    rendement_marche = ((valeur_finale - valeur_initiale) / valeur_initiale) * 100

    print(f"Rendement de Mastercard sur la période spécifiée : {rendement_marche:.2f}%")
else:
    print("Insuffisamment de données pour calculer le rendement de Mastercard sur cette période")

# Calcul du coefficient beta
covariance = historique_ma['Close'].cov(historical_data_snp500['Close'])
variance_marche = calculer_variance_marche(date_debut, date_fin)
beta = covariance / variance_marche
print(f"Coefficient bêta (beta) de Mastercard par rapport au marché : {beta:.2f}")
# MEDAF : Ks = rf + (Rm – rf) * Beta
ks = rf + (rm - rf) * beta
print(f"La valeur du MEDAF : {ks:.3F}")

if rendement_marche > ks:
    print("Action recommandée : Achat d'actions Mastercard")
else:
    print("Action recommandée : Ne pas acheter d'actions Mastercard")

# Calcul de Gordon-Shapiro
G = (latest_dividend / final_price) + tauxC[3]
print(f"La valeur de Gordon-Shapiro est : {G:.3F}")

if rendement_marche > G:
    print("Action recommandée : Achat d'actions Mastercard")
else:
    print("Action recommandée : Ne pas acheter d'actions Mastercard")

# 2ème méthode QTOBIN
Qtobin = final_price / 6.7
### 6.7 = valeur comptable par action

print(f"Le Q de Tobin est égal à : {Qtobin:.3F}")

if Qtobin > 1:
    print("Action recommandée : Achat d'actions Mastercard")
else:
    print("Action recommandée : Ne pas acheter d'actions Mastercard")

### https://fr.investing.com/equities/Mastercard-computer-inc-ratios

# 3ème méthode stochastique
cours_bas = historique_ma.iloc[-1]['Low']
cours_haut = historique_ma.iloc[-1]['High']
S = (valeur_finale - cours_bas) / (cours_haut - cours_bas)

print(f"La valeur stochastique est égale à : {S:.3F}")

if S < 20:
    print("Action recommandée : Achat d'actions Mastercard")
else:
    print("Action recommandée : Ne pas acheter d'actions Mastercard")

import yfinance as yf

# Récupération des données de l'action INTEL (INTC)
intc = yf.Ticker('INTC')  # Le symbole ^GSPC représente l'indice S&P 500

# Récupération de l'historique des prix de l'action INTEL sur une période spécifique
historique_intc = intc.history(start=date_debut, end=date_fin)
# Remplacez 'YYYY-MM-DD' par les dates de début et de fin souhaitées pour calculer le rendement

if not historique_intc.empty and len(historique_intc) >= 2:
    valeur_initiale = historique_intc.iloc[0]['Close']
    valeur_finale = historique_intc.iloc[-1]['Close']

    # Calcul du rendement du marché
    rendement_marche = ((valeur_finale - valeur_initiale) / valeur_initiale) * 100

    print(f"Rendement de INTEL sur la période spécifiée : {rendement_marche:.2f}%")
else:
    print("Insuffisamment de données pour calculer le rendement de INTEL sur cette période")

# Calcul du coefficient beta
covariance = historique_intc['Close'].cov(historical_data_snp500['Close'])
variance_marche = calculer_variance_marche(date_debut, date_fin)
beta = covariance / variance_marche
print(f"Coefficient bêta (beta) de INTEL par rapport au marché : {beta:.2f}")
# MEDAF : Ks = rf + (Rm – rf) * Beta
ks = rf + (rm - rf) * beta
print(f"La valeur du MEDAF : {ks:.3F}")

if rendement_marche > ks:
    print("Action recommandée : Achat d'actions INTEL")
else:
    print("Action recommandée : Ne pas acheter d'actions INTEL")

# Calcul de Gordon-Shapiro
G = (latest_dividend / final_price) + tauxC[4]
print(f"La valeur de Gordon-Shapiro est : {G:.3F}")

if rendement_marche > G:
    print("Action recommandée : Achat d'actions INTEL")
else:
    print("Action recommandée : Ne pas acheter d'actions INTEL")

# 2ème méthode QTOBIN
Qtobin = final_price / 24.31
### 24.31 = valeur comptable par action

print(f"Le Q de Tobin est égal à : {Qtobin:.3F}")

if Qtobin > 1:
    print("Action recommandée : Achat d'actions INTEL")
else:
    print("Action recommandée : Ne pas acheter d'actions INTEL")

### https://fr.investing.com/equities/INTEL-computer-inc-ratios

# 3ème méthode stochastique
cours_bas = historique_intc.iloc[-1]['Low']
cours_haut = historique_intc.iloc[-1]['High']
S = (valeur_finale - cours_bas) / (cours_haut - cours_bas)

print(f"La valeur stochastique est égale à : {S:.3F}")

if S < 20:
    print("Action recommandée : Achat d'actions INTEL")
else:
    print("Action recommandée : Ne pas acheter d'actions INTEL")

"""Dans ce projet, on a essayé 3 méthodes differentes pour voir si on veut acheter ou vendre un certain nombre d'actions, les méthodes sont on calculant la MEDAF,Qtobin et la valeur stochastique.

"""